<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Tactical Drawing Map</title>

    <link rel="stylesheet" href="/web/leaflet.css" />
    <script src="/web/leaflet.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>

    <style>
      html,
      body,
      #map {
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #0a0a0a;
      }

      .leaflet-container {
        background: #0a0a0a;
      }

      /* Aircraft marker */
      .aircraft-marker {
        width: 24px;
        height: 24px;
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
      }

      .aircraft-marker .marker-inner {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #00ff00;
        font-size: 20px;
        text-shadow: 0 0 5px #00ff00;
        transform-origin: center center;
      }

      .track-marker {
        width: 24px;
        height: 24px;
        background: transparent;
        border: none;
        padding: 0;
        margin: 0;
      }

      .track-marker .marker-inner {
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 18px;
        filter: drop-shadow(0 0 3px #ff0000);
        transform-origin: center center;
      }

      /* NEW: Waypoint editing markers */
      .waypoint-handle {
        width: 16px;
        height: 16px;
        background: #ffff00;
        border: 2px solid #ffffff;
        border-radius: 50%;
        cursor: move;
        box-shadow: 0 0 8px #ffff00;
      }

      .insertion-handle {
        width: 14px;
        height: 14px;
        background: #00ffff;
        border: 2px solid #ffffff;
        border-radius: 50%;
        cursor: pointer;
        box-shadow: 0 0 6px #00ffff;
        opacity: 0.7;
      }

      .insertion-handle:hover {
        opacity: 1;
        transform: scale(1.2);
      }

      .start-handle {
        width: 18px;
        height: 18px;
        background: #00ff00;
        border: 3px solid #ffffff;
        cursor: move;
        box-shadow: 0 0 10px #00ff00;
      }

      .end-handle {
        width: 18px;
        height: 18px;
        background: #ff0000;
        border: 3px solid #ffffff;
        cursor: move;
        box-shadow: 0 0 10px #ff0000;
      }

      /* Drawing instructions */
      #draw-instructions {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #00ff00;
        padding: 12px 24px;
        border: 2px solid #00ff00;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        font-weight: bold;
        font-size: 14px;
        z-index: 1000;
        display: none;
      }

      /* Editing mode instructions */
      #edit-instructions {
        position: absolute;
        top: 10px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.95);
        color: #ffff00;
        padding: 12px 24px;
        border: 2px solid #ffff00;
        border-radius: 5px;
        font-family: "Courier New", monospace;
        font-weight: bold;
        font-size: 14px;
        z-index: 1000;
        display: none;
      }
    </style>
  </head>
  <body>
    <div id="draw-instructions">
      Click on map to draw path. Double-click to finish.
    </div>
    <div id="edit-instructions">
      ðŸŸ¡ Drag waypoints to move | ðŸ”µ Click + to insert | Right-click to delete
    </div>
    <div id="map"></div>

    <script>
      // Initialize map - India centered, no black areas
      var map = L.map("map", {
        center: [20.5937, 78.9629],
        zoom: 5,
        minZoom: 2,
        maxZoom: 18,
        zoomControl: true,
        worldCopyJump: true,
        preferCanvas: true,
      });

      // Tile layer - allow wrapping to prevent black areas
      L.tileLayer("/tiles/{z}/{x}/{y}.png", {
        maxZoom: 18,
        minZoom: 2,
        maxNativeZoom: 8,
        noWrap: false,
        tileSize: 256,
        keepBuffer: 4,
        errorTileUrl:
          "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR4nGNgYAAAAAMAASsJTYQAAAAASUVORK5CYII=",
      }).addTo(map);

      // Limit map to world bounds to avoid showing black areas
      try {
        map.setMaxBounds([
          [-90, -180],
          [90, 180],
        ]);
      } catch (err) {
        // ignore if not supported
      }

      // Fix map size and center on India
      setTimeout(() => {
        map.invalidateSize();
        map.setView([20.5937, 78.9629], 5);
      }, 200);

      window.addEventListener("resize", () => {
        map.invalidateSize();
      });

      // Drawing state
      var drawingMode = null;
      var drawingPoints = [];
      var tempPolyline = null;
      var drawnPaths = {};
      var aircraftMarkers = {};
      var isDragging = false;
      var dragDrawingType = "aircraft"; // NEW: Track type for drag drawing

      // NEW: Editing state
      var editingMode = false;
      var editingPathId = null;
      var waypointHandles = [];
      var insertionHandles = [];
      var editingPolyline = null;
      var editingPathData = null;

      // Layers
      var aircraftPathLayer = L.layerGroup().addTo(map);
      var trackPathLayer = L.layerGroup().addTo(map);
      var markerLayer = L.layerGroup().addTo(map);
      var editingLayer = L.layerGroup().addTo(map); // NEW

      // Enable drawing
      function enableDrawing(mode) {
        drawingMode = mode;
        drawingPoints = [];

        var instructions = document.getElementById("draw-instructions");

        // Handle different modes
        if (mode === "drag_aircraft") {
          dragDrawingType = "aircraft";
          instructions.textContent =
            "Click and drag to draw AIRCRAFT path (Green). Release to finish.";
          instructions.style.display = "block";

          map.dragging.disable();
          map.on("mousedown", onDragStart);
        } else if (mode === "drag_track") {
          dragDrawingType = "track";
          instructions.textContent =
            "Click and drag to draw TRACK path (Red). Release to finish.";
          instructions.style.display = "block";

          map.dragging.disable();
          map.on("mousedown", onDragStart);
        } else if (mode === "aircraft") {
          instructions.textContent =
            "Click on map to draw AIRCRAFT path. Double-click to finish.";
          instructions.style.display = "block";

          map.on("click", onMapClick);
          map.on("dblclick", finishDrawing);
        } else if (mode === "track") {
          instructions.textContent =
            "Click on map to draw TRACK path. Double-click to finish.";
          instructions.style.display = "block";

          map.on("click", onMapClick);
          map.on("dblclick", finishDrawing);
        }

        map.getContainer().style.cursor = "crosshair";
      }

      function disableDrawing() {
        drawingMode = null;
        drawingPoints = [];

        document.getElementById("draw-instructions").style.display = "none";

        map.off("click", onMapClick);
        map.off("dblclick", finishDrawing);
        map.off("mousedown", onDragStart);
        map.off("mousemove", onDragMove);
        map.off("mouseup", onDragEnd);

        map.dragging.enable();

        if (tempPolyline) {
          map.removeLayer(tempPolyline);
          tempPolyline = null;
        }

        map.getContainer().style.cursor = "";
      }

      // Click drawing
      function onMapClick(e) {
        if (!drawingMode || drawingMode.startsWith("drag_")) return;

        // Ignore click events that are part of a double-click
        if (e.originalEvent && e.originalEvent.detail === 2) {
          return;
        }

        L.DomEvent.stopPropagation(e);

        drawingPoints.push([e.latlng.lat, e.latlng.lng]);

        if (tempPolyline) {
          map.removeLayer(tempPolyline);
        }

        var color = drawingMode === "aircraft" ? "#00ff00" : "#ff0000";
        tempPolyline = L.polyline(drawingPoints, {
          color: color,
          weight: 3,
          opacity: 0.7,
          dashArray: "10, 10",
        }).addTo(map);
      }

      function finishDrawing(e) {
        if (
          !drawingMode ||
          drawingPoints.length < 2 ||
          drawingMode.startsWith("drag_")
        ) {
          return;
        }

        L.DomEvent.stopPropagation(e);
        L.DomEvent.preventDefault(e);

        var distance = calculatePathDistance(drawingPoints);

        var pathData = {
          points: drawingPoints,
          distance_nm: distance,
          type: drawingMode,
        };

        if (typeof window.drawingBridge !== "undefined") {
          window.drawingBridge.onPathDrawn(JSON.stringify(pathData));
        }

        if (tempPolyline) {
          map.removeLayer(tempPolyline);
          tempPolyline = null;
        }

        drawingPoints = [];
      }

      // Drag drawing
      function onDragStart(e) {
        if (!drawingMode || !drawingMode.startsWith("drag_")) return;

        isDragging = true;
        drawingPoints = [];
        drawingPoints.push([e.latlng.lat, e.latlng.lng]);

        map.on("mousemove", onDragMove);
        map.on("mouseup", onDragEnd);
      }

      function onDragMove(e) {
        if (!isDragging) return;

        drawingPoints.push([e.latlng.lat, e.latlng.lng]);

        if (tempPolyline) {
          map.removeLayer(tempPolyline);
        }

        var color = dragDrawingType === "aircraft" ? "#00ff00" : "#ff0000";
        tempPolyline = L.polyline(drawingPoints, {
          color: color,
          weight: 3,
          opacity: 0.7,
          dashArray: "10, 10",
        }).addTo(map);
      }

      function onDragEnd(e) {
        if (!isDragging) return;

        isDragging = false;
        map.off("mousemove", onDragMove);
        map.off("mouseup", onDragEnd);

        if (drawingPoints.length < 2) {
          if (tempPolyline) {
            map.removeLayer(tempPolyline);
            tempPolyline = null;
          }
          drawingPoints = [];
          return;
        }

        var distance = calculatePathDistance(drawingPoints);

        var pathData = {
          points: drawingPoints,
          distance_nm: distance,
          type: dragDrawingType, // Use the correct type
        };

        if (typeof window.drawingBridge !== "undefined") {
          window.drawingBridge.onPathDrawn(JSON.stringify(pathData));
        }

        if (tempPolyline) {
          map.removeLayer(tempPolyline);
          tempPolyline = null;
        }

        drawingPoints = [];
      }

      function calculatePathDistance(points) {
        if (points.length < 2) return 0;

        var R = 3440.065;
        var totalDistance = 0;

        for (var i = 0; i < points.length - 1; i++) {
          var p1 = points[i];
          var p2 = points[i + 1];

          var lat1 = toRad(p1[0]);
          var lon1 = toRad(p1[1]);
          var lat2 = toRad(p2[0]);
          var lon2 = toRad(p2[1]);

          var dlat = lat2 - lat1;
          var dlon = lon2 - lon1;

          var a =
            Math.sin(dlat / 2) * Math.sin(dlat / 2) +
            Math.cos(lat1) *
              Math.cos(lat2) *
              Math.sin(dlon / 2) *
              Math.sin(dlon / 2);
          var c = 2 * Math.asin(Math.sqrt(a));

          totalDistance += R * c;
        }

        return totalDistance;
      }

      function toRad(deg) {
        return (deg * Math.PI) / 180;
      }

      function addPath(pathDataJson) {
        try {
          var path = JSON.parse(pathDataJson);

          // Draw path line
          var color = path.type === "aircraft" ? "#00ff00" : "#ff0000";
          var polyline = L.polyline(path.points, {
            color: color,
            weight: 2,
            opacity: 0.6,
          });

          if (path.type === "aircraft") {
            polyline.addTo(aircraftPathLayer);
          } else {
            polyline.addTo(trackPathLayer);
          }

          // Store path
          drawnPaths[path.id] = {
            path: path,
            polyline: polyline,
            marker: null,
          };

          // Create marker at FIRST point of path
          var markerClass =
            path.type === "aircraft" ? "aircraft-marker" : "track-marker";

          var htmlContent = "";
          if (path.type === "aircraft")
            htmlContent = '<div class="marker-inner">âœˆ</div>';
          else htmlContent = '<div class="marker-inner">ðŸŽ¯</div>';

          var icon = L.divIcon({
            className: "leaflet-div-icon " + markerClass,
            html: htmlContent,
            iconSize: [24, 24],
            iconAnchor: [12, 12],
          });

          var marker = L.marker(path.points[0], {
            icon: icon,
          });

          marker.addTo(markerLayer);
          marker.setZIndexOffset(1000);
          marker.setLatLng(path.points[0]);

          marker.bindPopup(
            "<b>" +
              path.id +
              "</b><br>" +
              "Speed: " +
              path.speed_kts +
              " kts<br>" +
              "Alt: " +
              path.altitude_ft +
              " ft<br>" +
              "Distance: " +
              path.distance_nm.toFixed(1) +
              " nm"
          );

          drawnPaths[path.id].marker = marker;
          aircraftMarkers[path.id] = marker;
        } catch (e) {
          console.error("Error adding path:", e);
        }
      }

      function updatePositions(updatesJson) {
        try {
          var updates = JSON.parse(updatesJson);

          updates.forEach(function (update) {
            if (aircraftMarkers[update.id]) {
              var marker = aircraftMarkers[update.id];

              // Update position
              marker.setLatLng([update.lat, update.lon]);

              // Update rotation
              if (marker.setRotationAngle) {
                marker.setRotationAngle(update.heading);
              }

              // Update popup
              marker.setPopupContent(
                "<b>" +
                  update.id +
                  "</b><br>" +
                  "Speed: " +
                  Math.round(update.speed) +
                  " kts<br>" +
                  "Alt: " +
                  Math.round(update.alt) +
                  " ft<br>" +
                  "Heading: " +
                  Math.round(update.heading) +
                  "Â°"
              );
            }
          });
        } catch (e) {
          console.error("Error updating positions:", e);
        }
      }

      function clearAllPaths() {
        aircraftPathLayer.clearLayers();
        trackPathLayer.clearLayers();
        markerLayer.clearLayers();
        editingLayer.clearLayers();
        drawnPaths = {};
        aircraftMarkers = {};
        editingMode = false;
        editingPathId = null;
      }

      // ==================== NEW: PATH EDITING FUNCTIONS ====================

      function startPathEditing(pathId) {
        try {
          // Stop any drawing mode
          disableDrawing();

          editingMode = true;
          editingPathId = pathId;

          // Get path data
          if (!drawnPaths[pathId]) {
            console.error("Path not found:", pathId);
            return;
          }

          editingPathData = drawnPaths[pathId].path;

          // Hide original polyline
          if (drawnPaths[pathId].polyline) {
            map.removeLayer(drawnPaths[pathId].polyline);
          }

          // Create highlighted editing polyline
          var color =
            editingPathData.type === "aircraft" ? "#00ff00" : "#ff0000";
          editingPolyline = L.polyline(editingPathData.points, {
            color: color,
            weight: 4,
            opacity: 0.9,
          }).addTo(editingLayer);

          // Create waypoint handles
          createWaypointHandles();

          // Create insertion handles (midpoints)
          createInsertionHandles();

          // Show editing instructions
          document.getElementById("edit-instructions").style.display = "block";

          // Disable map dragging during editing
          map.dragging.disable();
        } catch (e) {
          console.error("Error starting path editing:", e);
        }
      }

      function stopPathEditing() {
        try {
          editingMode = false;

          // Clear editing layer
          editingLayer.clearLayers();
          waypointHandles = [];
          insertionHandles = [];

          // Restore original polyline
          if (editingPathId && drawnPaths[editingPathId]) {
            var path = drawnPaths[editingPathId].path;
            var color = path.type === "aircraft" ? "#00ff00" : "#ff0000";
            var polyline = L.polyline(path.points, {
              color: color,
              weight: 2,
              opacity: 0.6,
            });

            if (path.type === "aircraft") {
              polyline.addTo(aircraftPathLayer);
            } else {
              polyline.addTo(trackPathLayer);
            }

            drawnPaths[editingPathId].polyline = polyline;
          }

          editingPathId = null;
          editingPolyline = null;
          editingPathData = null;

          // Hide editing instructions
          document.getElementById("edit-instructions").style.display = "none";

          // Re-enable map dragging
          map.dragging.enable();
        } catch (e) {
          console.error("Error stopping path editing:", e);
        }
      }

      function createWaypointHandles() {
        waypointHandles = [];

        editingPathData.points.forEach(function (point, index) {
          var isStart = index === 0;
          var isEnd = index === editingPathData.points.length - 1;

          var iconClass = isStart
            ? "start-handle"
            : isEnd
            ? "end-handle"
            : "waypoint-handle";

          var icon = L.divIcon({
            className: iconClass,
            iconSize: [16, 16],
            iconAnchor: [8, 8],
          });

          var marker = L.marker(point, {
            icon: icon,
            draggable: true,
          }).addTo(editingLayer);

          // Drag events
          marker.on("drag", function (e) {
            onWaypointDrag(index, e.target.getLatLng());
          });

          marker.on("dragend", function (e) {
            onWaypointDragEnd(index, e.target.getLatLng());
          });

          // Right-click to delete (except start and end)
          if (!isStart && !isEnd) {
            marker.on("contextmenu", function (e) {
              L.DomEvent.preventDefault(e);
              deleteWaypoint(index);
            });
          }

          waypointHandles.push(marker);
        });
      }

      function createInsertionHandles() {
        insertionHandles = [];

        for (var i = 0; i < editingPathData.points.length - 1; i++) {
          var p1 = editingPathData.points[i];
          var p2 = editingPathData.points[i + 1];

          // Calculate midpoint
          var midLat = (p1[0] + p2[0]) / 2;
          var midLon = (p1[1] + p2[1]) / 2;

          var icon = L.divIcon({
            className: "insertion-handle",
            html: "+",
            iconSize: [14, 14],
            iconAnchor: [7, 7],
          });

          var insertIndex = i + 1;
          var marker = L.marker([midLat, midLon], {
            icon: icon,
            draggable: true,
          }).addTo(editingLayer);

          // When dragged, convert to waypoint
          marker.on("dragstart", function (e) {
            var currentIndex = insertionHandles.indexOf(e.target);
            if (currentIndex !== -1) {
              e.target._insertIndex = currentIndex + 1;
            }
          });

          marker.on("drag", function (e) {
            // Show visual feedback
          });

          marker.on("dragend", function (e) {
            var insertIdx = e.target._insertIndex;
            var newLatLng = e.target.getLatLng();
            insertWaypoint(insertIdx, newLatLng);
          });

          insertionHandles.push(marker);
        }
      }

      function onWaypointDrag(index, newLatLng) {
        // Update path points
        editingPathData.points[index] = [newLatLng.lat, newLatLng.lng];

        // Update polyline
        editingPolyline.setLatLngs(editingPathData.points);

        // Update insertion handles
        updateInsertionHandles();

        // Notify Python (real-time update)
        if (typeof window.drawingBridge !== "undefined") {
          var updateData = {
            pathId: editingPathId,
            index: index,
            lat: newLatLng.lat,
            lon: newLatLng.lng,
          };
          window.drawingBridge.onWaypointMoved(JSON.stringify(updateData));
        }
      }

      function onWaypointDragEnd(index, newLatLng) {
        // Final update
        editingPathData.points[index] = [newLatLng.lat, newLatLng.lng];

        // Update path data in storage
        if (drawnPaths[editingPathId]) {
          drawnPaths[editingPathId].path.points = editingPathData.points;
        }
      }

      function insertWaypoint(insertIndex, newLatLng) {
        // Insert new waypoint
        editingPathData.points.splice(insertIndex, 0, [
          newLatLng.lat,
          newLatLng.lng,
        ]);

        // Update path data in storage
        if (drawnPaths[editingPathId]) {
          drawnPaths[editingPathId].path.points = editingPathData.points;
        }

        // Notify Python
        if (typeof window.drawingBridge !== "undefined") {
          var insertData = {
            pathId: editingPathId,
            insertIndex: insertIndex,
            lat: newLatLng.lat,
            lon: newLatLng.lng,
          };
          window.drawingBridge.onWaypointInserted(JSON.stringify(insertData));
        }

        // Recreate handles
        editingLayer.clearLayers();
        editingPolyline = L.polyline(editingPathData.points, {
          color:
            editingPathData.type === "aircraft" ? "#00ff00" : "#ff0000",
          weight: 4,
          opacity: 0.9,
        }).addTo(editingLayer);

        createWaypointHandles();
        createInsertionHandles();
      }

      function deleteWaypoint(index) {
        // Minimum 2 waypoints required
        if (editingPathData.points.length <= 2) {
          alert("Cannot delete waypoint. Minimum 2 waypoints required.");
          return;
        }

        // Remove waypoint
        editingPathData.points.splice(index, 1);

        // Update path data in storage
        if (drawnPaths[editingPathId]) {
          drawnPaths[editingPathId].path.points = editingPathData.points;
        }

        // Notify Python
        if (typeof window.drawingBridge !== "undefined") {
          var deleteData = {
            pathId: editingPathId,
            index: index,
          };
          window.drawingBridge.onWaypointDeleted(JSON.stringify(deleteData));
        }

        // Recreate handles
        editingLayer.clearLayers();
        editingPolyline = L.polyline(editingPathData.points, {
          color:
            editingPathData.type === "aircraft" ? "#00ff00" : "#ff0000",
          weight: 4,
          opacity: 0.9,
        }).addTo(editingLayer);

        createWaypointHandles();
        createInsertionHandles();
      }

      function updateInsertionHandles() {
        // Remove old insertion handles
        insertionHandles.forEach(function (handle) {
          editingLayer.removeLayer(handle);
        });

        // Recreate insertion handles
        createInsertionHandles();
      }

      function deletePath(pathId) {
        if (drawnPaths[pathId]) {
          // Remove polyline
          if (drawnPaths[pathId].polyline) {
            map.removeLayer(drawnPaths[pathId].polyline);
          }

          // Remove marker
          if (drawnPaths[pathId].marker) {
            map.removeLayer(drawnPaths[pathId].marker);
          }

          // Remove from storage
          delete drawnPaths[pathId];
          delete aircraftMarkers[pathId];
        }
      }

      // ==================== END PATH EDITING FUNCTIONS ====================

      // WebChannel connection
      if (typeof QWebChannel !== "undefined" && typeof qt !== "undefined") {
        new QWebChannel(qt.webChannelTransport, function (channel) {
          window.drawingBridge = channel.objects.drawingBridge;

          window.drawingBridge.enableDrawing.connect(enableDrawing);
          window.drawingBridge.disableDrawing.connect(disableDrawing);
          window.drawingBridge.clearAllPaths.connect(clearAllPaths);
          window.drawingBridge.addPath.connect(addPath);
          window.drawingBridge.updatePosition.connect(updatePositions);

          // NEW: Connect editing signals
          window.drawingBridge.startPathEditing.connect(startPathEditing);
          window.drawingBridge.stopPathEditing.connect(stopPathEditing);
          window.drawingBridge.pathDeleted.connect(deletePath);
        });
      } else {
        console.warn("QWebChannel not available; running without Qt bridge.");
      }

      // Leaflet rotation plugin
      (function () {
        var _oldSetPos = L.Marker.prototype._setPos;

        L.Marker.include({
          _setPos: function (pos) {
            _oldSetPos.call(this, pos);

            try {
              var inner =
                this._icon && this._icon.querySelector
                  ? this._icon.querySelector(".marker-inner")
                  : null;

              if (inner && typeof this.options.rotationAngle !== "undefined") {
                inner.style.transform =
                  "rotate(" + this.options.rotationAngle + "deg)";
              }
            } catch (err) {
              // ignore styling errors
            }
          },
          setRotationAngle: function (angle) {
            this.options.rotationAngle = angle;

            try {
              var inner =
                this._icon && this._icon.querySelector
                  ? this._icon.querySelector(".marker-inner")
                  : null;

              if (inner) {
                inner.style.transform = "rotate(" + angle + "deg)";
              } else {
                this.update();
              }
            } catch (err) {
              this.update();
            }

            return this;
          },
        });
      })();
    </script>
  </body>
</html>
